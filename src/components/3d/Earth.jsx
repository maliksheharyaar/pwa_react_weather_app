/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 earth.gltf 
Author: Akshat (https://sketchfab.com/shooter24994)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/earth-41fc80d85dfd480281f21b74b2de2faa
Title: Earth
*/

import React, { useMemo, useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { useLoader, useFrame } from '@react-three/fiber'
import { TextureLoader, Euler, Vector3, Quaternion } from 'three'

function latLonToCartesian(lat, lon, radius) {
  const phi = (90 - lat) * Math.PI / 180;
  const theta = (lon + 90) * Math.PI / 180;
  const x = radius * Math.sin(phi) * Math.sin(theta);
  const y = radius * Math.cos(phi);
  const z = radius * Math.sin(phi) * Math.cos(theta);
  return [x, y, z];
}

function getArrowRotation(markerPos) {
  if (!markerPos) return [0, 0, 0];
  // Direction vector from globe center to marker, then flip (reverse direction)
  const dir = new Vector3(...markerPos).normalize().negate();
  // Default cone points +Y, so rotate to align +Y to dir
  const target = new Vector3(0, 1, 0);
  const quaternion = new Quaternion().setFromUnitVectors(target, dir);
  const euler = new Euler().setFromQuaternion(quaternion);
  return [euler.x, euler.y, euler.z];
}

export default function Model({ lat, lon, ...props }) {
  const groupRef = useRef();
  const { nodes } = useGLTF(`${import.meta.env.BASE_URL}earth.gltf`)
  const colorMap = useLoader(TextureLoader, `${import.meta.env.BASE_URL}textures/Material.002_diffuse.jpeg`)
  colorMap.flipY = false;
  const RADIUS = 100;

  // Marker position for searched city
  const markerPos = useMemo(() => {
    if (lat === undefined || lon === undefined) return null;
    return latLonToCartesian(lat, lon, RADIUS);
  }, [lat, lon]);

  // Only rotate on Y axis (longitude), multiply by -1
  const targetRotation = useMemo(() => {
    if (lon === undefined) return new Euler(0, 0, 0, 'XYZ');
    const y = -1 * ( -((lon + 90) * Math.PI / 180) );
    return new Euler(0, y, 0, 'XYZ');
  }, [lon]);

  useFrame(() => {
    if (groupRef.current) {
      groupRef.current.rotation.y += 0.003;
    }
  });

  useEffect(() => {
    if (groupRef.current && lat !== undefined && lon !== undefined) {
      groupRef.current.rotation.y = targetRotation.y;
    }
  }, [targetRotation, lat, lon]);

  // Arrow position: slightly above the marker
  const arrowPos = useMemo(() => {
    if (!markerPos) return null;
    // Move up by 10 units in the direction of the marker's position vector
    const [x, y, z] = markerPos;
    const length = Math.sqrt(x*x + y*y + z*z);
    const scale = (length + 10) / length;
    return [x * scale, y * scale, z * scale];
  }, [markerPos]);

  // Arrow rotation: point towards the marker
  const arrowRot = useMemo(() => getArrowRotation(markerPos), [markerPos]);

  return (
    <group {...props} dispose={null} ref={groupRef}>
      <mesh geometry={nodes.Sphere_Material002_0.geometry} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
        <meshStandardMaterial map={colorMap} />
      </mesh>
      {markerPos && (
        <>
          <mesh position={markerPos}>
            <sphereGeometry args={[2, 32, 32]} />
            <meshStandardMaterial color="yellow" emissive="yellow" emissiveIntensity={0.8} />
          </mesh>
          {arrowPos && (
            <mesh position={arrowPos} rotation={arrowRot}>
              <coneGeometry args={[2, 6, 16]} />
              <meshStandardMaterial color="orange" emissive="orange" emissiveIntensity={0.7} />
            </mesh>
          )}
        </>
      )}
    </group>
  )
}

useGLTF.preload(`${import.meta.env.BASE_URL}earth.gltf`)
